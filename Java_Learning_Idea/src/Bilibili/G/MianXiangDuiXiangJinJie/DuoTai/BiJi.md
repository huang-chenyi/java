# 多态笔记

---

## 多态的表现形式：

（父类对象 对象名称 = 子类对象）（Fu f = new Zi();）

### 前提：

1. 有 继承/实现 关系

2. 有 父类引用 指向 子类对象

3. 有 方法重写

---

## 多态调用成员的特点：

### 1. 成员变量的调用：编译看左边，运行也看左边

**（指的是public型变量，而非private型变量用getter方法的调用）**

编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。

运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值

### 2. 成员方法的调用：编译看左边，运行看右边

编译看左边：javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，如果没有编译失败。

运行看右边：java运行代码的时候，实际上运行的是子类中的方法

## 理解

Animal a = new Dog();

现在用a去调用变量和方法

而a是Animal类型的，所以默认都会从Animal这个类中去找

- 调用成员变量：使用多态方法定义变量时，在子类的对象中，会把父类的成员变量也继承下的

- 调用成员方法：如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖的

### 调用成员方法的理解

实际上就是调用成员方法时，事实上是在调用**父类方法在子类之中的重写方法**

所以正常情况下，多态调用成员方法无法调用子类独有的方法

如果必须调用子类的独有方法，可以使用强制类型转换

如：Fu f = new Zi();

Zi z = (Zi) f;

该代码即将f强制转换为Zi类后赋值给z，然后就可以使用z调用子类之中的独有方法

但是如果你试图将f强制转换成Zi2类型（Zi2 z = (Zi2) f），则无法做到

因此，在转换时还可以做一个**安全判断措施**

if(f instanceof Zi){
Zi z = (Zi) f; 
}

**java14后新增功能**

作用是先判断，再强转，

如果f是Zi类型，则将f转化为Zi类并赋给z，即与上方代码作用一致

如果f不是Zi类型 则不做转换，返回false

if(f instanceof Zi z){
}



